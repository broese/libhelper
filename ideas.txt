Ideas for the libhelper

Buffers

ALLOCATE(name) // a macro with cast and malloc etc.
allocate_buffer(len)
automatic buffer (readpos, readlen)

File operations

get_file_length(path);
read_file(path, buffer, length);
write_file(path, data, length)

Directory operations

see what we did for dirlib

Network

open_udp_client_socket
open_udp_server_socket
open_tcp_client_socket(peer_hostname,peer_port)
open_tcp_server_socket(bind_ip, bind_port)
get_host_ip(hostname)
send_packet(socket, data, len)
send_request(socket, data, len, rxbuf, rxlen);
receive_request(socket, checking_function);

Image files

write_png24(data, width, height, stride, path)
write_jpeg(data, width, height, stride, path)
read_png(&data, &width, &height, &stride, format*, path);

SDL

create_surface32(width, height)
flip_serface
draw_line
draw_circle
fill_flood(surface,x,y)

Archive files

read_gzip(&data, &len, path)
read_archive(&data, &len, path) - determines format automatically
write_gzip(data, len, path)

strings, Regexp

split, join, match

////////////////////////////////////////////////////////////////////////////////

Implementing a packet parser

// the parser implies a couple of variables in the scope, which might be hidden
// from the user's view through macros. Since the variables will be initialized,
// it is sensible to enclose it in a block 
uint8_t *s : start of the bytestream (for rewinding) - IS THIS NECESSARY? - yes maybe to calculate length
uint8_t *p : pointer to the bytestream - 
uint8_t *l : read limit

// A macro to initialize the environment of the parser.
Pinit(buffer, buffer+len);

#define Pinit(buffer_start, buffer_limit) uint_t *s = buffer_start; uint_t *p = s; uint_t *l = buffer_limit;

// 